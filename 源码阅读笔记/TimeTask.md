TimerThread 是一个处理定时任务的线程，继承自Thread。定时任务线程，有两个关键的字眼:`线程+任务定时执行`。

1、线程：

这部分很简单，就是 TimerThread继承自Thread，start()执行之后就开启了一个线程。

2、任务定时执行：

这部一份是定时执行的关键。`任务`也很简单，是一个实现 Runnable 接口的 TimerTask 虚拟类。
业务处理逻辑都是写在实现run()方法内。也可以看出，定时任务是没有返回值的。

`定时执行`才是关键所在！从字面上看，会认为线程是像设定了一个"闹钟"一样，时间到了就执行任务。
但是，这只是表象！你会不会认为，设置线程的wait()时间，到时间了线程就执行了，这就是定时任务。

若是一个线程只执行一个任务，这种方式也可以实现。但，若是一个线程需要执行多个定时任务呢？所以，我们就要考虑
`定时`的不是线程，而是`任务`。

打个比方，在一个流水线上有一个工人(线程)，流水线(任务队列)上源源不断的送来包裹(定时任务)。每一个包裹都是按紧急处理顺序在流水线上传送，
若是包裹上写了它要被处理的时间点，工人每次都只拿第一个包裹，看一下当前时间若是时间到了就处理包裹，若是时间没到就等待一下。

以上只是一个简单的类比，有了大概的概念，`执行时间`是任务自生携带的属性。

`任务类型：`
①、一次性执行任务；

②、固定周期，从任务初次被触发开始，以后每隔period时间就被触发一次。
不用等待上一次任务处理完，若是执行周期到了，即开始执行。

③、固定延时，任务下次的开始时间=任务上次结束时间+(-period),需等待上一次任务执行完，等待周期时间后才再次执行。

`任务队列：`
底层是一个一维数组，没有实现线程安全的一维数组。用数组的方式实现一个小顶堆数据结构。每一个任务添加进任务队列中，
会根据任务的运行到期时间做排序。最早需要运行的任务，放在数组下标[1]的位置。

线程不断的(死循环)从`任务队列`中获取下标[1]的任务，看查一下任务是否可以执行(任务的定时时间是否已到期)，若是任务还不可执行，那么
会让线程sleep(xxx)(因为下标[1]的任务就是最快到期的任务，若是最快到期的任务都还不能执行，那么其他任务可定也还未到期)。
sleep()到期之后，执行下标[1]的任务。

若是任务为`一次性任务`，从队列中移除，然后再执行。

若是`固定周期`，那么 任务执行时间+周期 作为 任务下一次的运行时间。把任务重新放回 `任务队列`中。

若是`固定延时`，那么 当前时间+周期 作为 任务下一次的运行时间。把任务重新放回 `任务队列`中。


